before:
  this_module = 'posix'
  global_table = '_G'

  M = require(this_module)

specify posix.deprecated:
- before:
    socket, getaddrinfo, close = M.socket, M.getaddrinfo, M.close
    AF_INET, AF_INET6, AF_UNIX, AF_NETLINK =
       M.AF_INET, M.AF_INET6, M.AF_UNIX, M.AF_NETLINK
    SOCK_STREAM = M.SOCK_STREAM

    EPOCH = M.time()

- context when required:
  - it does not touch the global table:
      expect(show_apis {added_to=global_table, by=this_module}).
         to_equal {}

- describe connect:
  - before:
      connect, typeerrors = init(M, "connect")

  - context with bad arguments: |
      badargs.diagnose(connect, "connect(int, table)")

      examples {
         ["it diagnoses wrong family types"] = function()
            expect(connect(42, {family=false})).
               to_raise.any_of(typeerrors(2, "int", "family", "boolean"))
            expect(connect(42, {family=-1})).to_raise.any_of {
               "bad argument #2 to '?' (unsupported family type -1)",
               "bad argument #2 to 'connect' (unsupported family type -1)",
           }
        end
      }
      examples {
         ["it diagnoses wrong AF_INET field types"] = function()
            expect(connect(42, {family=AF_INET, port=false})).
               to_raise.any_of(typeerrors(2, "int", "port", "boolean"))
            expect(connect(42, {family=AF_INET, port=9999, addr=false})).
               to_raise.any_of(typeerrors(2, "string", "addr", "boolean"))
         end
      }
      examples {
         ["it diagnoses invalid AF_INET fields"] = function()
            expect(connect(42, {
               family=AF_INET, port=9999, addr="127.0.0.1", flags=false
            })).to_raise.any_of(typeerrors(2, nil, "flags"))
         end
      }
      examples {
         ["it diagnoses wrong AF_INET6 field types"] = function()
            expect(connect(42, {family = AF_INET6, port = false})).
               to_raise.any_of(typeerrors(2, "int", "port", "boolean"))
            expect(connect(42, {family = AF_INET6, port = 9999, addr = false})).
               to_raise.any_of(typeerrors(2, "string", "addr", "boolean"))
         end
      }
      examples {
         ["it diagnoses invalid AF_INET6 fields"] = function()
            expect(connect(42, {
               family=AF_INET6, port=9999, addr="::", flags=false
            })).to_raise.any_of(typeerrors(2, nil, "flags"))
         end
      }
      examples {
         ["it diagnoses wrong AF_UNIX field types"] = function()
            expect(connect(42, {family = AF_UNIX, path = false})).
               to_raise.any_of(typeerrors(2, "string", "path", "boolean"))
         end
      }
      examples {
         ["it diagnoses invalid AF_UNIX fields"] = function()
            expect(connect(42, {family=AF_UNIX, path="/tmp/afunix", port=9999})).
               to_raise.any_of(typeerrors(2, nil, "port"))
         end
      }
      if AF_NETLINK then
         examples {
            ["it diagnoses wrong AF_NETLINK field types"] = function()
                 expect(connect(42, {family = AF_NETLINK, pid = false})).
                    to_raise.any_of(typeerrors(2, "int", "pid", "boolean"))
                 expect(connect(42, {family = AF_NETLINK, pid = 9999, groups = false})).
                    to_raise.any_of(typeerrors(2, "int", "groups", "boolean"))
            end
         }
         examples {
            ["it diagnoses invalid AF_NETLINK fields"] = function()
               expect(connect(42, {family=AF_NETLINK, pid=9999, groups=9999, port=9999})).
                  to_raise.any_of(typeerrors(2, nil, "port"))
            end
         }
      end

  - it returns true on success:
      fd = socket(AF_INET, SOCK_STREAM, 0)
      ait = getaddrinfo("www.lua.org", "http", {family = AF_INET, socktype = SOCK_STREAM})
      expect(connect(fd, ait[1])).to_be(true)
      close(fd)



- describe bind:
  - before:
      bind, typeerrors = init(M, "bind")

  - context with bad arguments: |
      badargs.diagnose(bind, "bind(int, table)")

      examples {
         ["it diagnoses wrong family types"] = function()
            expect(bind(42, {family=false})).
               to_raise.any_of(typeerrors(2, "int", "family", "boolean"))
            expect(bind(42, {family=-1})).to_raise.any_of {
               "bad argument #2 to '?' (unsupported family type -1)",
               "bad argument #2 to 'bind' (unsupported family type -1)",
            }
         end
      }
      examples {
         ["it diagnoses wrong AF_INET field types"] = function()
            expect(bind(42, {family=AF_INET, port=false})).
               to_raise.any_of(typeerrors(2, "int", "port", "boolean"))
            expect(bind(42, {family=AF_INET, port=9999, addr=false})).
               to_raise.any_of(typeerrors(2, "string", "addr", "boolean"))
         end
      }
      examples {
         ["it diagnoses invalid AF_INET fields"] = function()
            expect(bind(42, {
               family=AF_INET, port=9999, addr="127.0.0.1", flags=false
            })).to_raise.any_of(typeerrors(2, nil, "flags"))
         end
      }
      examples {
         ["it diagnoses wrong AF_INET6 field types"] = function()
            expect(bind(42, {family = AF_INET6, port = false})).
               to_raise.any_of(typeerrors(2, "int", "port", "boolean"))
            expect(bind(42, {family = AF_INET6, port = 9999, addr = false})).
               to_raise.any_of(typeerrors(2, "string", "addr", "boolean"))
         end
      }
      examples {
         ["it diagnoses invalid AF_INET6 fields"] = function()
            expect(bind(42, {
               family=AF_INET6, port=9999, addr="::", flags=false
            })).to_raise.any_of(typeerrors(2, nil, "flags"))
         end
      }
      examples {
         ["it diagnoses wrong AF_UNIX field types"] = function()
            expect(bind(42, {family = AF_UNIX, path = false})).
               to_raise.any_of(typeerrors(2, "string", "path", "boolean"))
         end
      }
      examples {
         ["it diagnoses invalid AF_UNIX fields"] = function()
            expect(bind(42, {family=AF_UNIX, path="/tmp/afunix", port=9999})).
               to_raise.any_of(typeerrors(2, nil, "port"))
         end
      }
      if AF_NETLINK then
         examples {
            ["it diagnoses wrong AF_NETLINK field types"] = function()
                 expect(bind(42, {family = AF_NETLINK, pid = false})).
                    to_raise.any_of(typeerrors(2, "int", "pid", "boolean"))
                 expect(bind(42, {family = AF_NETLINK, pid = 9999, groups = false})).
                    to_raise.any_of(typeerrors(2, "int", "groups", "boolean"))
            end
         }
         examples {
            ["it diagnoses invalid AF_NETLINK fields"] = function()
               expect(bind(42, {family=AF_NETLINK, pid=9999, groups=9999, port=9999})).
                  to_raise.any_of(typeerrors(2, nil, "port"))
            end
         }
      end

  - it returns true on success:
      fd = socket(AF_INET, SOCK_STREAM, 0)
      expect(bind(fd, {family = AF_INET, addr = "127.0.0.1", port = 13457 })).to_be(true)
      close(fd)


- describe clock_getres:
  - before:
      clock_getres = M.clock_getres

  - context with bad arguments:
      if clock_getres then
         badargs.diagnose(clock_getres, "clock_getres(?string)")
      end

  - it takes deprecated string arguments:
      if clock_getres then
         local time = require 'posix.time'

         expect(clock_getres()).
            to_be(time.clock_getres(time.CLOCK_REALTIME).tv_sec)
         expect(clock_getres 'monotonic').
            to_be(time.clock_getres(time.CLOCK_MONOTONIC).tv_sec)
         expect(clock_getres 'process_cputime_id').
            to_be(time.clock_getres(time.CLOCK_PROCESS_CPUTIME_ID).tv_sec)
         expect(clock_getres 'thread_cputime_id').
            to_be(time.clock_getres(time.CLOCK_THREAD_CPUTIME_ID).tv_sec)
      end


- describe clock_gettime:
  - before:
      clock_gettime = M.clock_gettime

  - context with bad arguments:
      if clock_gettime then
         badargs.diagnose(clock_gettime, "clock_gettime(?string)")
      end

  - it takes deprecated string arguments:
      if clock_gettime then
         local time = require 'posix.time'

         expect(clock_gettime()).
            to_be(time.clock_gettime(time.CLOCK_REALTIME).tv_sec)
         expect(clock_gettime 'monotonic').
            to_be(time.clock_gettime(time.CLOCK_MONOTONIC).tv_sec)
         expect(clock_gettime 'process_cputime_id').
            to_be(time.clock_gettime(time.CLOCK_PROCESS_CPUTIME_ID).tv_sec)
         expect(clock_gettime 'thread_cputime_id').
            to_be(time.clock_gettime(time.CLOCK_THREAD_CPUTIME_ID).tv_sec)
      end


- describe exec:
  - before:
      exec, typeerrors = init(M, "exec")

  # M.exec takes a string or non-empty table as its second
  # argument, followed by zero or more strings only if the second
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not string':
        expect(exec(false)).to_raise.any_of(typeerrors(1, "string", "boolean"))
    - 'it diagnoses argument #2 type not table or string':
        expect(exec("cmd", false)).
           to_raise.any_of(typeerrors(2, "?string|table", "boolean"))
    - 'it diagnoses argument #3 type not string':
        expect(exec("cmd", "cmd", false)).
           to_raise.any_of(typeerrors(3, "string", "boolean"))
    - it diagnoses too many arguments:
        expect(exec("cmd", {}, false)).to_raise.any_of(typeerrors(3))


- describe execp:
  - before:
      # redirect output to /dev/null
      dup2, fork, open, wait, O_WRONLY, O_APPEND =
         M.dup2, M.fork, M.open, M.wait, M.O_WRONLY, M.O_APPEND
      P_CHILD = 0

      function child(...)
         quietly = open("/dev/null", bor(O_WRONLY, O_APPEND))
         dup2(quietly, 1)
         execp(...)
         expect("not reached").to_be(true)
      end

      execp, typeerrors = init(M, "execp")

  # M.execp takes a string or non-empty table as its second
  # argument, followed by zero or more strings only if the second
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not string':
        expect(execp(false)).to_raise.any_of(typeerrors(1, "string", "boolean"))
    - 'it diagnoses argument #2 type not table or string':
        expect(execp("cmd", false)).
           to_raise.any_of(typeerrors(2, "?string|table", "boolean"))
    - 'it diagnoses argument #3 type not string':
        expect(execp("cmd", "cmd", false)).
           to_raise.any_of(typeerrors(3, "string", "boolean"))
    - it diagnoses too many arguments:
        expect(execp("cmd", {}, false)).to_raise.any_of(typeerrors(3))

  - it overwrites the running process with a shell invocation:
      process = fork()
      if process == P_CHILD then
         child("date", "+[%c]")
      else
         p, msg, ret = wait(process)
         expect(table.concat {msg, " ", tostring(ret)}).to_be "exited 0"
      end
  - it accepts a table of arguments:
      process = fork()
      if process == P_CHILD then
         child("date", {"+[%c]"})
      else
         p, msg, ret = wait(process)
         expect(table.concat {msg, " ", tostring(ret)}).to_be "exited 0"
      end
  - "it sets argv[0]":


- describe fadvise:
  - context with bad arguments:
      if M.fadvise then
         badargs.diagnose(M.fadvise, "fadvise(FILE*, int, int, int)")
      end


- describe fnmatch:
  - before:
      fnmatch, FNM_PATHNAME, FNM_PERIOD =
         M.fnmatch, M.FNM_PATHNAME, M.FNM_PERIOD

  - context with bad arguments:
      badargs.diagnose(fnmatch, "fnmatch(string, string, ?int)")

  - it matches a file path against itself:
      expect(fnmatch("test", "test")).to_be(true)
  - "it matches * against any filename characters":
      expect(fnmatch("tes*", "test")).to_be(true)
      expect(fnmatch("tes*", "test2")).to_be(true)
      expect(fnmatch("*t*", "test")).to_be(true)
  - "it matches ? against a single filename character":
      expect(fnmatch("tes?", "test")).to_be(true)
      expect(fnmatch("t???", "test")).to_be(true)
      expect(fnmatch("tes?", "tes")).to_be(false)
      expect(fnmatch("tes?", "test2")).to_be(false)
  - "it doesn't match path separators with FNM_PATHNAME":
      expect(fnmatch("*test", "/test")).to_be(true)
      expect(fnmatch("*test", "/test", FNM_PATHNAME)).to_be(false)
  - "it doesn't match periods with FNM_PERIOD":
      expect(fnmatch("*test", ".test")).to_be(true)
      expect(fnmatch("*test", ".test", FNM_PERIOD)).to_be(false)


- describe getgroup:
  - before:
      getgrgid, getgroup, getegid =
         M.getgrgid, M.getgroup, M.getegid
      groot = getgrgid(0).gr_name

  - context with bad arguments:
      badargs.diagnose(M.getgroup, "getgroup(?int|string)")

  - it returns a table for an existing group:
      expect(type(getgroup(groot))).to_be "table"
  - it fetches current group by default:
      expect(getgroup()).to_equal(getgroup(getegid()))
  - it fetches a group by gid:
      expect(getgroup(0).name).to_be(groot)
      expect(getgroup(0).gid).to_be(0)
      expect(type(getgroup(0).mem)).to_be "table"
  - it fetches a group by name:
      expect(getgroup(groot).name).to_be(groot)
      expect(getgroup(groot).gid).to_be(0)
      expect(type(getgroup(groot).mem)).to_be "table"


- describe getpasswd:
  - before:
      getenv, getgid, getpasswd, getuid =
         M.getenv, M.getgid, M.getpasswd, M.getuid
      user = getpasswd((getenv "USER"), "name")
      root = getpasswd(0, "name")

  - context with bad arguments:
    - before:
        getpasswd, typeerrors = init(posix, "getpasswd")

    - 'it diagnoses argument #1 type not int, string or nil':
        expect(getpasswd(false)).
           to_raise.any_of(typeerrors(1, "?int|string", "boolean"))

  - it fetches the user uid:
      expect(getpasswd(user).uid).to_be(getuid())
      expect(getpasswd(root, "uid")).to_be(0)
  - it fetches the user name:
      expect(getpasswd(user).name).to_be(user)
      expect(getpasswd(0, "name")).to_be(root)
      expect(getpasswd(root, "name")).to_be(root)
  - it fetches the user gid:
      expect(getpasswd(user).gid).to_be(getgid())
      expect(getpasswd(0, "gid")).to_be(0)
      expect(getpasswd(root, "gid")).to_be(0)
  - it fetches the user password:
      expect(getpasswd(user).passwd).to_match.any_of {"x", "%*+"}
      expect(getpasswd(0, "passwd")).to_match.any_of {"x", "%*+"}
      expect(getpasswd(root, "passwd")).to_match.any_of {"x", "%*+"}
  - it fetches the user home directory:
      expect(getpasswd(user, "dir")).to_be(getenv "HOME")
  - it fetches a subtable of named fields:
      expect({getpasswd(user, "name", "dir")}).
         to_equal {user, getenv "HOME"}
  - it fetches everything without an argument:
      t = getpasswd(user)
      for k, v in pairs(t) do
         expect(t[k]).to_be(getpasswd(user, k))
      end


- describe getpid:
  - before:
      unistd = M.unistd

      getpid, typeerrors = init(M, "getpid")

  # M.getpid takes an optional string or table as its first
  # argument, followed by zero or more strings only if the first
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not table, string or nil':
        expect(getpid(false)).to_raise.
           any_of(typeerrors(1, "?string|table", "boolean"))
    - 'it diagnoses argument #1 string invalid': |
        expect(getpid("fubar")).to_raise.any_of {
           "bad argument #1 to '?' (invalid option 'fubar')",
           "bad argument #1 to 'getpid' (invalid option 'fubar')",
        }
    - 'it diagnoses argument #2 type not string':
        expect(getpid("ppid", false)).
           to_raise.any_of(typeerrors(2, "string", "boolean"))
    - it diagnoses too many arguments:
        expect(getpid({}, false)).to_raise.any_of(typeerrors(2))

    - it fetches the effective group id:
        expect(getpid().egid).to_be(unistd.getegid())
        expect(getpid "egid").to_be(unistd.getegid())
    - it fetches the effective user id:
        expect(getpid().euid).to_be(unistd.geteuid())
        expect(getpid "euid").to_be(unistd.geteuid())
    - it fetches the group id:
        expect(getpid().gid).to_be(unistd.getgid())
        expect(getpid "gid").to_be(unistd.getgid())
    - it fetches the user id:
        expect(getpid().uid).to_be(unistd.getuid())
        expect(getpid "uid").to_be(unistd.getuid())
    - it fetches the process group:
        expect(getpid().pgrp).to_be(unistd.getpgrp())
        expect(getpid "pgrp").to_be(unistd.getpgrp())
    - it fetches the process id:
        expect(getpid().pid).to_be(unistd.getpid())
        expect(getpid "pid").to_be(unistd.getpid())
    - it fetches the parent process id:
        expect(getpid().ppid).to_be(unistd.getppid())
        expect(getpid "ppid").to_be(unistd.getppid())
    - it returns them all when called with no argument:
        expect(getpid()).to_equal {
           egid = unistd.getegid(),
           euid = unistd.geteuid(),
           gid = unistd.getgid(),
           uid = unistd.getuid(),
           pgrp = unistd.getpgrp(),
           pid = unistd.getpid(),
           ppid = unistd.getppid(),
        }


- describe getrlimit:
  - before:
      getrlimit = M.getrlimit

  - context with bad arguments: |
      examples {
         ["it diagnoses argument #1 invalid option"] = function()
            expect(getrlimit("fubar")).to_raise.any_of {
               "bad argument #1 to '?' (invalid option 'fubar')",
               "bad argument #1 to 'getrlimit' (invalid option 'fubar')",
            }
         end
      }

      badargs.diagnose(getrlimit, "getrlimit(string)")

  - it fetches resource limits for a process:
      for _, rc in pairs {"core", "cpu", "data", "fsize", "nofile", "stack", "as"}
      do
         cur, max = getrlimit(rc)
         expect(type(cur)).to_be "number"
         expect(type(max)).to_be "number"
      end


- describe gettimeofday:
  - before:
      gettimeofday = M.gettimeofday

  - context with bad arguments:
      badargs.diagnose(gettimeofday, "gettimeofday()")

  - it fetches the current epoch time:
      t = gettimeofday()
      expect(t.sec).to_be_within_n_of {value=EPOCH, delta=1}
      expect(type(t.usec)).to_be "number"
      expect(t.usec >= 0).to_be(true)


- describe gmtime:
  - before:
      gmtime = M.gmtime

  - context with bad arguments:
      badargs.diagnose(gmtime, "gmtime(?int)")

  - it returns a table:
      expect(prototype(gmtime(EPOCH))).to_be "table"
  - it fetches broken-down time values:
      t = gmtime(EPOCH)
      fields = {"sec", "min", "hour", "day", "monthday", "month", "year",
         "weekday", "yearday", "is_dst"}
      if t.gmtoff ~= nil then fields[1+#fields] = "gmtoff" end
      if t.zone ~= nil then fields[1+#fields] = "zone" end
      expect(t).to_contain.a_permutation_of(fields)
      for _, field in pairs(fields) do
         if field == "zone" then
           expect(type(t[field])).to_be "string"
         elseif field == "is_dst" then
           expect(type(t[field])).to_be "boolean"
         else
           expect(type(t[field])).to_be "number"
           if field ~= "gmtoff" then
             expect(t[field] >= 0).to_be(true)
           else
             expect(t[field] == 0).to_be(true)
           end
         end
      end
  - it returns a month in the range 1-12:
      # A recent December afternoon in epoch seconds...
      expect(gmtime(1418734089).month).to_be(12)
      t = gmtime(EPOCH)
      expect(t.month >= 1 and t.month <= 12).to_be(true)
  - it returns full year:
      expect(gmtime(EPOCH).year > 2000).to_be(true)


- describe hostid:
  - context with bad arguments:
      badargs.diagnose(M.hostid, "()")


- describe isgraph:
  - before:
      isgraph = M.isgraph

  - context with bad arguments:
      badargs.diagnose(isgraph, "isgraph(string)")

  - it returns true for successful tests:
      expect(isgraph 'a').to_be(true)
  - it returns false for failed tests:
      expect(isgraph ' ').to_be(false)


- describe isprint:
  - before:
      isprint = M.isprint

  - context with bad arguments:
      badargs.diagnose(isprint, "isprint(string)")

  - it returns true for successful tests:
      expect(isprint 'a').to_be(true)
  - it returns false for failed tests:
      expect(isprint(string.char(0))).to_be(false)


- describe localtime:
  - before:
      localtime = M.localtime

  - context with bad arguments:
      badargs.diagnose(localtime, "localtime(?int)")

  - it returns a table:
      expect(prototype(localtime(EPOCH))).to_be "table"
  - it fetches broken-down time values:
      t = localtime(EPOCH)
      fields = {"sec", "min", "hour", "day", "monthday", "month", "year",
         "weekday", "yearday", "is_dst"}
      if t.gmtoff ~= nil then fields[1+#fields] = "gmtoff" end
      if t.zone ~= nil then fields[1+#fields] = "zone" end
      expect(t).to_contain.a_permutation_of(fields)
      for _, field in pairs(fields) do
         if field == "zone" then
           expect(type(t[field])).to_be "string"
         elseif field == "is_dst" then
           expect(type(t[field])).to_be "boolean"
         else
           expect(type(t[field])).to_be "number"
           if field ~= "gmtoff" then
             expect(t[field] >= 0).to_be(true)
           end
         end
      end
  - it returns a month in the range 1-12:
      # A recent December afternoon in epoch seconds...
      expect(localtime(1418734089).month).to_be(12)
      t = localtime(EPOCH)
      expect(t.month >= 1 and t.month <= 12).to_be(true)
  - it returns years since 1900:
      expect(localtime(EPOCH).year > 2000).to_be(true)


- describe mktime:
  - before:
      localtime, mktime, time = M.localtime, M.mktime, M.time
      t = localtime(EPOCH)

  - context with bad arguments:
      badargs.diagnose(mktime, "mktime(?table)")

  - it returns an epoch time:
      expect(prototype(mktime(t))).to_be "number"
  - it is the inverse of localtime:
      expect(mktime(t)).to_be_within_n_of {value=EPOCH, delta=1}
  - it defaults to current time:
      expect(mktime()).to_be_within_n_of {value=EPOCH, delta=1}


- describe nanosleep:
  - context with bad arguments:
      badargs.diagnose(M.nanosleep, "nanosleep(int, int)")

  - it returns an integer:
      expect(M.nanosleep(0, 10)).to_be(0)


- describe openlog:
  - before:
      openlog = M.openlog

  - context with bad arguments: |
      if openlog then
         badargs.diagnose(openlog, "openlog(string, ?string, ?int)")

         examples {
            ["it diagnoses invalid options"] = function()
               expect(openlog("log", "cp*")).to_raise.any_of {
                  "bad argument #2 to '?' (invalid openlog option '*')",
                  "bad argument #2 to 'openlog' (invalid openlog option '*')",
               }
            end
         }
      end


- describe pathconf:
  - before:
      pathconf, typeerrors = init(posix, "pathconf")

  # M.pathconf takes an optional string or table as its second
  # argument, followed by zero or more strings only if the second
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not string':
        expect(pathconf(false)).
           to_raise.any_of(typeerrors(1, "?string", "boolean"))
    - 'it diagnoses argument #2 type not string, table or nil':
        expect(pathconf(".", false)).
           to_raise.any_of(typeerrors(2, "?string|table", "boolean"))
    - 'it diagnoses argument #2 string invalid': |
        expect(pathconf(".", "fubar")).to_raise.any_of {
           "bad argument #2 to '?' (invalid option 'fubar')",
           "bad argument #2 to 'pathconf' (invalid option 'fubar')",
        }
    - 'it diagnoses argument #3 type not string':
        expect(pathconf(".", "NAME_MAX", false)).
           to_raise.any_of(typeerrors(3, "string", "boolean"))
    - it diagnoses too many arguments:
        expect(pathconf(".", {}, false)).to_raise.any_of(typeerrors(3))

  - it returns whether chown can be used on the given file:
      expect(type(pathconf().CHOWN_RESTRICTED)).to_be "number"
      expect(pathconf(".", "CHOWN_RESTRICTED") >= 0).to_be(true)
  - it fetches the maximum number of links to the given file:
      expect(type(pathconf().LINK_MAX)).to_be "number"
      expect(pathconf(".", "LINK_MAX") >= 0).to_be(true)
  - it fetches the maximum formatted line input length for a tty: |
      -- not passing a tty, so should return -1
      expect(type(pathconf().MAX_CANON)).to_be "number"
      pending "issue #102"
      expect(pathconf(".", "MAX_CANON")).to_be(-1)
  - it fetches the maximum raw line input length for a tty: |
      -- not passing a tty, so should return -1
      expect(type(pathconf().MAX_INPUT)).to_be "number"
      pending "issue #102"
      expect(pathconf(".", "MAX_INPUT")).to_be(-1)
  - it fetches the maximum filename length in this directory:
      expect(type(pathconf().NAME_MAX)).to_be "number"
      expect(pathconf(".", "NAME_MAX") >= 0).to_be(true)
  - it fetches whether accessing overlong filenames is an error:
      expect(type(pathconf().NO_TRUNC)).to_be "number"
      expect(pathconf(".", "NO_TRUNC") >= 0).to_be(true)
  - it fetches the maximum relative path length from this directory:
      expect(type(pathconf().PATH_MAX)).to_be "number"
      expect(pathconf(".", "PATH_MAX") >= 0).to_be(true)
  - it fetches the size of the pipe buffer:
      expect(type(pathconf().PIPE_BUF)).to_be "number"
      expect(pathconf(".", "PIPE_BUF") >= 0).to_be(true)
  - it fetches whether special character processing can be disabled: |
      -- not passing a tty, so should return -1
      expect(type(pathconf().VDISABLE)).to_be "number"
      pending "issue #102"
      expect(pathconf(".", "VDISABLE")).to_be(-1)
  - it fetches a subtable of named fields:
      expect({pathconf(".", "VDISABLE", "NAME_MAX")}).
         to_equal {pathconf(".", "VDISABLE"), pathconf(".", "NAME_MAX")}
  - it fetches everything without an argument:
      t = pathconf()
      for k, v in pairs(t) do
         expect(t[k]).to_be(pathconf(".", k))
      end


- describe setrlimit:
  - before:
      setrlimit = M.setrlimit

  - context with bad arguments: |
      examples {
         ["it diagnoses argument #1 invalid option"] = function()
            expect(setrlimit("fubar")).to_raise.any_of {
               "bad argument #1 to '?' (invalid option 'fubar')",
               "bad argument #1 to 'setrlimit' (invalid option 'fubar')",
            }
         end
      }

      badargs.diagnose(setrlimit, "setrlimit(string, ?int, ?int)")


- describe stat:
  - before:
      fmt = "%b %d %H:%M"
      getegid, geteuid = M.getegid, M.geteuid
      stat, typeerrors = init(posix, "stat")

      dir = M.mkdtemp(template)
      M.chown(dir, geteuid(), getegid())
      M.mkdir(dir .. "/subdir")
      M.link("subdir", dir .. "/soft", true)
      touch(dir .. "/file")
      M.link(dir .. "/file", dir .. "/hard")
      M.link("no such destination", dir .. "/dangling", true)
      M.mkfifo(dir .. "/fifo")

  - after:
      rmtmp(dir)

  # M.stat takes an optional string or table as its second
  # argument, followed by zero or more strings only if the second
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses missing argument #1':
        expect(stat()).to_raise.any_of(typeerrors(1, "string"))
    - 'it diagnoses argument #1 type not string':
        expect(stat(false)).
           to_raise.any_of(typeerrors(1, "string", "boolean"))
    - 'it diagnoses argument #2 type not string, table or nil':
        expect(stat(".", false)).
          to_raise.any_of(typeerrors(2, "?string|table", "boolean"))
    - 'it diagnoses argument #2 string invalid': |
        expect(stat(".", "fubar")).to_raise.any_of {
           "bad argument #2 to '?' (invalid option 'fubar')",
           "bad argument #2 to 'stat' (invalid option 'fubar')",
        }
    - 'it diagnoses argument #3 type not string':
        expect(stat(".", "type", false)).
           to_raise.any_of(typeerrors(3, "string", "boolean"))
    - it diagnoses too many arguments:
        expect(stat(".", {}, false)).
           to_raise.any_of(typeerrors(3))

  - it fetches the file inode:
      expect(stat(dir .. "/hard").ino).to_be(stat(dir .. "/file").ino)
  - it fetches the file type:
      expect(stat(dir).type).to_be "directory"
      expect(stat(dir .. "/file", "type")).to_be "regular"
      expect(stat(dir .. "/soft", "type")).to_be "link"
      expect(stat(dir .. "/hard", "type")).to_be "regular"
  - it fetches the file size:
      # skip directory size, which is system dependent
      expect(stat(dir .. "/file").size).to_be(0)
      expect(stat(dir .. "/soft", "size")).to_be(string.len("subdir"))
      expect(stat(dir .. "/hard", "size")).
         to_be(stat(dir .. "/file", "size"))
  - it fetches the file access time:
      expect(stat(dir .. "/file", "atime")).
         to_be_within_n_of {value=EPOCH, delta=1}
  - it fetches the file modification time:
      expect(stat(dir .. "/file", "mtime")).
         to_be_within_n_of {value=EPOCH, delta=1}
  - it fetches the file creation time:
      expect(stat(dir .. "/file", "ctime")).
         to_be_within_n_of {value=EPOCH, delta=2}
  - it fetches the file access mode:
      expect(stat(dir .. "/file").mode).to_match("^[-rwx]+$")
      expect(stat(dir .. "/subdir", "mode")).to_match("^[-rwx]+$")
  - it fetches the number of links:
      expect(stat(dir .. "/file").nlink).to_be(2)
      expect(stat(dir .. "/soft", "nlink")).to_be(1)
      expect(stat(dir .. "/hard", "nlink")).
         to_be(stat(dir .. "/file", "nlink"))
      expect(stat(dir .. "/subdir", "nlink")).to_be(2)
  - it fetches the owner id:
      expect(stat(dir .. "/file").uid).to_be(geteuid())
      expect(stat(dir .. "/subdir", "uid")).to_be(geteuid())
  - it fetches the owner group id:
      expect(stat(dir .. "/file").gid).to_be(getegid())
      expect(stat(dir .. "/subdir", "gid")).to_be(getegid())
  - it fetches a subtable of named fields:
      expect({stat(dir .. "/file", "type", "size", "nlink")}).
         to_equal {"regular", 0, 2}
  - it fetches everything without an argument:
      t = stat(dir .. "/file")
      for k, v in pairs(t) do
         expect(t[k]).to_be(stat(dir .. "/file", k))
      end


- describe statvfs:
  - before:
      statvfs, typeerrors = init(posix, "statvfs")

  # M.statvfs takes an optional string or table as its second
  # argument, followed by zero or more strings only if the second
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments: |
      if statvfs then
         examples {
            ["it diagnoses missing argument #1"] = function()
               expect(statvfs()).to_raise.any_of(typeerrors(1, "string"))
            end
         }
         examples {
            ["it diagnoses argument #1 type not string"] = function()
               expect(statvfs(false)).
                  to_raise.any_of(typeerrors(1, "string", "boolean"))
            end
         }
         examples {
            ["it diagnoses argument #2 type not string, table or nil"] = function()
               expect(statvfs(".", false)).
                  to_raise.any_of(typeerrors(2, "?string|table", "boolean"))
            end
         }
         examples {
            ["it diagnoses argument #2 string invalid"] = function()
               expect(statvfs(".", "fubar")).to_raise.any_of {
                  "bad argument #2 to '?' (invalid option 'fubar')",
                  "bad argument #2 to 'statvfs' (invalid option 'fubar')",
               }
            end
         }
         examples {
            ["it diagnoses argument #3 type not string"] = function()
               expect(statvfs(".", "files", false)).
                  to_raise.any_of(typeerrors(3, "string", "boolean"))
            end
         }
         examples {
            ["it diagnoses too many arguments"] = function()
               expect(statvfs(".", {}, false)).to_raise.any_of(typeerrors(3))
            end
         }
      end

  - it fetches statistics for a mounted file system:
      if statvfs then
         sv = statvfs "/"
         expect(type(sv)).to_be "table"
         expect(sv.bsize).to_be(statvfs("/", "bsize"))
         for _, field in pairs {"bsize", "frsize", "blocks", "bfree", "bavail",
                               "files", "ffree", "favail", "flag", "namemax"}
         do
            expect(type(sv[field])).to_be "number"
            expect(sv[field] >= 0).to_be(true)
         end
      end
  - it returns a non-negative value from fsid: |
      -- Merge this back into the previous example when #102 is fixed
      if statvfs then
         sv = statvfs "/"
         pending "issue #102"
         expect(sv[field] >= 0).to_be(true)
      end


- describe strftime:
  - before:
      strftime = M.strftime

      t = {
         is_dst = true, weekday = 0, sec = 2, min = 3, hour = 4,
         monthday = 5, month = 6, year = 7, yearday = 8
      }

  - context with bad arguments:
      badargs.diagnose(strftime, "strftime(string, ?table)")

  - context with place-holders:
    - it plugs weekday:
        expect(strftime("%w", t)).to_be "0"
    - it plugs sec:
        expect(strftime("%S", t)).to_be "02"
    - it plugs min:
        expect(strftime("%M", t)).to_be "03"
    - it plugs hour:
        expect(strftime("%H", t)).to_be "04"
    - it plugs monthday:
        expect(strftime("%d", t)).to_be "05"
    - it plugs month:
        expect(strftime("%m", t)).to_be "06"
    - it plugs year:
        expect(strftime("%y", t)).to_be "07"
    - it plugs yearday:
        expect(strftime("%j", t)).to_be "009"
  - it defaults to current time:
      f = io.popen("date +'%Y-%m-%d'", "r")
      expect(strftime "%Y-%m-%d\n").
         to_be(f:read("*a"))
      f:close()

- describe strptime:
  - before:
      strptime = M.strptime

  - context with bad arguments:
      badargs.diagnose(strptime, "strptime(string, string)")

  - context with place-holders:
    - before:
        t, i = strptime("Mon Jun  4 03:02:01 BST 1906 garbage",
                         "%a %b %d %H:%M:%S BST %Y")
    - it returns the first unconsumed character:
        expect(i).to_be(29)
    # tm_yday and tm_isdst are not set by strptime
    - it scans into weekday:
        expect(t.weekday).to_be(1)
    - it scans into sec:
        expect(t.sec).to_be(1)
    - it scans into min:
        expect(t.min).to_be(2)
    - it scans into hour:
        expect(t.hour).to_be(3)
    - it scans into monthday:
        expect(t.monthday).to_be(4)
    - it scans into month:
        expect(t.month).to_be(6)
    - it scans into year:
        expect(t.year).to_be(1906)


- describe sysconf:
  - before:
      sysconf, typeerrors = init(posix, "sysconf")

      positive_or_minusone = function(value)
         expect(type(value)).to_be "number"
         expect(value).not_to_be(0)
         expect(value >= -1).to_be(true)
      end

  # M.sysconf takes an optional string or table as its first
  # argument, followed by zero or more strings only if the first
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not string, table or nil':
        expect(sysconf(false)).
           to_raise.any_of(typeerrors(1, "?string|table", "boolean"))
    - 'it diagnoses argument #1 string invalid': |
        expect(sysconf("fubar")).to_raise.any_of {
           "bad argument #1 to '?' (invalid option 'fubar')",
           "bad argument #1 to 'sysconf' (invalid option 'fubar')",
        }
    - 'it diagnoses argument #2 type not string':
        expect(sysconf("ARG_MAX", false)).
           to_raise.any_of(typeerrors(2, "string", "boolean"))
    - it diagnoses too many arguments:
        expect(sysconf({}, false)).to_raise.any_of(typeerrors(2))

  - it fetches the maximum number of exec arguments:
      positive_or_minusone(sysconf().ARG_MAX)
      positive_or_minusone(sysconf "ARG_MAX")
  - it fetches the number processes per user:
      positive_or_minusone(sysconf().CHILD_MAX)
      positive_or_minusone(sysconf "CHILD_MAX")
  - it fetches the number of clock ticks per second:
      positive_or_minusone(sysconf().CLK_TCK)
      positive_or_minusone(sysconf "CLK_TCK")
  - it fetches the job control version:
      positive_or_minusone(sysconf().JOB_CONTROL)
      positive_or_minusone(sysconf "JOB_CONTROL")
  - it fetches the maximum number of groups:
      positive_or_minusone(sysconf().NGROUPS_MAX)
      positive_or_minusone(sysconf "NGROUPS_MAX")
  - it fetches the maximum number of open descriptors:
      positive_or_minusone(sysconf().OPEN_MAX)
      positive_or_minusone(sysconf "OPEN_MAX")
  - it fetches the size of memory pages:
      positive_or_minusone(sysconf().PAGESIZE)
      positive_or_minusone(sysconf "PAGESIZE")
  - it fetches the number of saved ids:
      positive_or_minusone(sysconf().SAVED_IDS)
      positive_or_minusone(sysconf "SAVED_IDS")
  - it fetches the maximum number of open streams:
      positive_or_minusone(sysconf().STREAM_MAX)
      positive_or_minusone(sysconf "STREAM_MAX")
  - it fetches the maximum length of a timezone name:
      positive_or_minusone(sysconf().TZNAME_MAX)
      positive_or_minusone(sysconf "TZNAME_MAX")
  - "it fetches the POSIX.1 version":
      positive_or_minusone(sysconf().VERSION)
      positive_or_minusone(sysconf "VERSION")
  - it fetches a subtable of named fields:
      expect({sysconf("VERSION", "ARG_MAX", "OPEN_MAX")}).
         to_equal {sysconf "VERSION", sysconf "ARG_MAX", sysconf "OPEN_MAX"}
  - it fetches everything without an argument:
      t = sysconf()
      for k, v in pairs(t) do
         expect(t[k]).to_be(sysconf(k))
      end


- describe times:
  - before:
      table.unpack = table.unpack or unpack
      times, typeerrors = init(posix, "times")

  # M.times takes an optional string or table as its first
  # argument, followed by zero or more strings only if the first
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not string, table or nil':
        expect(times(false)).
           to_raise.any_of(typeerrors(1, "?string|table", "boolean"))
    - 'it diagnoses argument #1 string invalid': |
        expect(times("fubar")).to_raise.any_of {
           "bad argument #1 to '?' (invalid option 'fubar')",
           "bad argument #1 to 'times' (invalid option 'fubar')",
        }
    - 'it diagnoses argument #2 type not string':
        expect(times("utime", false)).
           to_raise.any_of(typeerrors(2, "string", "boolean"))
    - it diagnoses too many arguments:
        expect(times({}, false)).to_raise.any_of(typeerrors(2))

  - it fetches the user time:
      expect(type(times().utime)).to_be "number"
      expect(times("utime") >= 0).to_be(true)
  - it fetches the system time:
      expect(type(times().stime)).to_be "number"
      expect(times("stime") >= 0).to_be(true)
  - it fetches the children user time:
      expect(type(times().cutime)).to_be "number"
      expect(times("cutime") >= 0).to_be(true)
  - it fetches the children system time:
      expect(type(times().cstime)).to_be "number"
      expect(times("cstime") >= 0).to_be(true)
  - it fetches the elapsed time:
      expect(type(times().elapsed)).to_be "number"
      expect(times("elapsed") >= 0).to_be(true)
  - it fetches a subtable of named fields: |
      keys = {"utime", "cutime"}
      t = {times(table.unpack(keys))}
      for _, v in ipairs(t) do
         expect(type(v)).to_be "number"
      end
  - it fetches everything without an argument:
      keys = {"utime", "stime", "cutime", "cstime", "elapsed"}
      t = times()
      expect(t).to_contain.all_of(keys)
      for _, v in ipairs(keys) do
         expect(type(t[v])).to_be "number"
      end


- describe uname:
  - before:
      uname = M.uname

  - context with bad arguments: |
      badargs.diagnose(uname, "uname(?string)")

      examples {
         ['it diagnoses bad specifier format options'] = function()
            expect(uname("foo %_")).
               to_error "bad argument #1 to 'uname' (invalid format option '_')"
         end
      }

  - it substitutes %n:
      expect(uname "%n").to_be(cmd_output "uname -n")
  - it substitutes %m:
      expect(uname "%m").to_be(cmd_output "uname -m")
  - it substitutes %r:
      expect(uname "%r").to_be(cmd_output "uname -r")
  - it outputs everything with no arguments:
      expect(uname():gsub("%s+"," "):gsub("%s$","")).to_be(cmd_output("uname -s -n -r -v -m"):gsub("%s+"," "):gsub("%s$",""))
